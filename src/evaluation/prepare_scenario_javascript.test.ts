import { expect } from "chai"

import { Scenario } from "../data/interface"
import { init_new_data_component } from "../data/modify"
import { deindent } from "../utils/deindent"
import { prepare_scenario_javascript } from "./prepare_scenario_javascript"


describe("prepare_scenario_javascript", () =>
{
    const min_arg_temp_id = "0"
    const value_arg_temp_id = "1"
    const offset_arg_temp_id = "2"
    const component_fixture = (scenario: Scenario) => init_new_data_component({
        value_type: "function",
        input_value: "Math.max(value, min) + offset",
        function_arguments: [
            { local_temp_id: min_arg_temp_id, name: "min", default_value: "0" },
            { local_temp_id: value_arg_temp_id, name: "value" },
            { local_temp_id: offset_arg_temp_id, name: "offset", default_value: "10" },
        ],
        // This should be generated by format_function_input_value_string
        // from the input_value and function_arguments
        result_value: "(min = 0, value, offset = 10) => Math.max(value, min) + offset",

        scenarios: [scenario]
    })

    const scenario_fixture = (): Scenario => ({
        local_temp_id: "1",
        description: "Test Scenario",
        values_by_temp_id: { [value_arg_temp_id]: { value: "5" } },
    })


    it("prepares javascript with scenario values", () =>
    {
        const scenario = scenario_fixture()
        const component = component_fixture(scenario)
        const javascript = prepare_scenario_javascript({ component, scenario })
        const expected = deindent(`
        function calc()
        {
            func = (min = 0, value, offset = 10) => Math.max(value, min) + offset;

            let result = undefined;

            result = func(undefined, 5, undefined);

            return result;
        }
        calc();
        `)

        expect(javascript).equals(expected)
    })


    it("should handling iterating over one variable", () =>
    {
        const scenario = scenario_fixture()
        scenario.values_by_temp_id[value_arg_temp_id] = { value: "[1,2,3]", iterate_over: true }
        const component = component_fixture(scenario)

        const javascript = prepare_scenario_javascript({ component, scenario })
        const expected = deindent(`
        function calc()
        {
            func = (min = 0, value, offset = 10) => Math.max(value, min) + offset;

            let result = undefined;
            const results = [];

            // iterate over argument "value" (local_temp_id: 1)
            const labels = [1,2,3];

            labels.forEach(value =>
            {
                result = func(undefined, value, undefined);
                results.push(result);
            });

            return { labels, results };
        }
        calc();
        `)

        expect(javascript).equals(expected)
    })


    it("should reject iterating over two variables", () =>
    {
        const scenario = scenario_fixture()
        scenario.values_by_temp_id[min_arg_temp_id] = { value: "[0, 2, 4]", iterate_over: true }
        scenario.values_by_temp_id[value_arg_temp_id] = { value: "[1,2,3]", iterate_over: true }
        const component = component_fixture(scenario)

        expect(() => prepare_scenario_javascript({ component, scenario })).throws("Can only iterate over one input at a time")
        // const expected = deindent(`
        // function calc()
        // {
        //     func = (min = 0, value, offset = 10) => Math.max(value, min) + offset;

        //     // iterate over argument "min"
        //     return [0, 2, 4].map(min =>
        //     {
        //         // iterate over argument "value"
        //         return [1,2,3].map(value =>
        //         {
        //             return func(min, value, undefined);
        //         });
        //     });
        // }
        // calc();
        // `)

        // expect(javascript).equals(expected)
    })


    it("should handle empty value strings", () =>
    {
        const scenario = scenario_fixture()
        scenario.values_by_temp_id[min_arg_temp_id] = { value: "" }
        const component = component_fixture(scenario)

        const javascript = prepare_scenario_javascript({ component, scenario })
        const expected = deindent(`
            function calc()
            {
                func = (min = 0, value, offset = 10) => Math.max(value, min) + offset;

                let result = undefined;

                result = func(undefined, 5, undefined);

                return result;
            }
            calc();
        `)

        expect(javascript).equals(expected)
    })


    it("should handle empty value for interate", () =>
    {
        const scenario = scenario_fixture()
        scenario.values_by_temp_id[min_arg_temp_id] = { value: "", iterate_over: true }
        const component = component_fixture(scenario)

        const javascript = prepare_scenario_javascript({ component, scenario })
        const expected = deindent(`
            function calc()
            {
                func = (min = 0, value, offset = 10) => Math.max(value, min) + offset;

                let result = undefined;
                const results = [];

                // iterate over argument "min" (local_temp_id: 0)
                const labels = [];

                labels.forEach(min =>
                {
                    result = func(min, 5, undefined);
                    results.push(result);
                });

                return { labels, results };
            }
            calc();
        `)

        expect(javascript).equals(expected)
    })


    describe("use_previous_result", () =>
    {
        it("should implement use_previous_result", () =>
        {
            const scenario = scenario_fixture()
            scenario.values_by_temp_id[min_arg_temp_id] = { value: "[1, 2, 3]", iterate_over: true }
            scenario.values_by_temp_id[offset_arg_temp_id] = { value: "", use_previous_result: true }
            const component = component_fixture(scenario)

            const javascript = prepare_scenario_javascript({ component, scenario })
            const expected = deindent(`
                function calc()
                {
                    func = (min = 0, value, offset = 10) => Math.max(value, min) + offset;

                    // Set initial result to "offset" (local_temp_id: 2) argument value
                    let result = undefined;
                    const results = [];

                    // iterate over argument "min" (local_temp_id: 0)
                    const labels = [1, 2, 3];

                    labels.forEach(min =>
                    {
                        result = func(min, 5, result);
                        results.push(result);
                    });

                    return { labels, results };
                }
                calc();
            `)

            expect(javascript).equals(expected)
        })


        it("should support using value as initial value for use_previous_result", () =>
        {
            const scenario = scenario_fixture()
            scenario.values_by_temp_id[min_arg_temp_id] = { value: "[1, 2, 3]", iterate_over: true }
            scenario.values_by_temp_id[offset_arg_temp_id] = { value: "456", use_previous_result: true }
            const component = component_fixture(scenario)

            const javascript = prepare_scenario_javascript({ component, scenario })
            const expected = deindent(`
                function calc()
                {
                    func = (min = 0, value, offset = 10) => Math.max(value, min) + offset;

                    // Set initial result to "offset" (local_temp_id: 2) argument value
                    let result = 456;
                    const results = [];

                    // iterate over argument "min" (local_temp_id: 0)
                    const labels = [1, 2, 3];

                    labels.forEach(min =>
                    {
                        result = func(min, 5, result);
                        results.push(result);
                    });

                    return { labels, results };
                }
                calc();
            `)

            expect(javascript).equals(expected)
        })
    })
})
